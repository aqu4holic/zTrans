[{"id":1,"code":"void init_game() {}","filename":"games/plusminus/champions/cxx/prologin.cc","fullname":"init_game:void()","name":"init_game"},{"id":2,"code":"void play_turn()\n{\n    if (my_team() == 1)\n        guess(42);\n    else\n        guess(13);\n}","filename":"games/plusminus/champions/cxx/prologin.cc","fullname":"play_turn:void()","name":"play_turn"},{"id":3,"code":"void end_game() {}","filename":"games/plusminus/champions/cxx/prologin.cc","fullname":"end_game:void()","name":"end_game"},{"id":4,"code":"static inline error guess(int guess)\n{\n    return api_guess(guess);\n}","filename":"games/plusminus/champions/cxx/prologin.hh","fullname":"guess","name":"guess"},{"id":5,"code":"static inline int my_team()\n{\n    return api_my_team();\n}","filename":"games/plusminus/champions/cxx/prologin.hh","fullname":"my_team","name":"my_team"},{"id":6,"code":"static inline int result()\n{\n    return api_result();\n}","filename":"games/plusminus/champions/cxx/prologin.hh","fullname":"result","name":"result"},{"id":7,"code":"static inline bool cancel()\n{\n    return api_cancel();\n}","filename":"games/plusminus/champions/cxx/prologin.hh","fullname":"cancel","name":"cancel"},{"id":8,"code":"static inline void afficher_error(error v)\n{\n    api_afficher_error(v);\n}","filename":"games/plusminus/champions/cxx/prologin.hh","fullname":"afficher_error","name":"afficher_error"},{"id":9,"code":"int ActionGuess::check(const GameState& /* st */) const\n{\n    if (guess_ < 0 || guess_ > 100)\n        return OUT_OF_BOUNDS;\n    return OK;\n}","filename":"games/plusminus/src/action_guess.cc","fullname":"ActionGuess.check:int(GameState &)","name":"check"},{"id":10,"code":"void ActionGuess::apply_on(GameState* st) const\n{\n    int result;\n    if (guess_ == st->secret_number)\n    {\n        st->secret_number_found = true;\n        result = 0;\n    }\n    else if (guess_ < st->secret_number)\n        result = -1;\n    else\n        result = 1;\n\n    st->player_guess_map[player_id_] = result;\n}","filename":"games/plusminus/src/action_guess.cc","fullname":"ActionGuess.apply_on:void(GameState*)","name":"apply_on"},{"id":11,"code":"Api::Api(std::unique_ptr<GameState> game_state,\n         std::shared_ptr<rules::Player> player)\n    : rules::Api<GameState, error>(std::move(game_state), player)\n{\n    api = this;\n}","filename":"games/plusminus/src/api.cc","fullname":"Api.Api:ANY(ANY,ANY)","name":"Api"},{"id":12,"code":"int Api::my_team()\n{\n    return player_->id;\n}","filename":"games/plusminus/src/api.cc","fullname":"Api.my_team:int()","name":"my_team"},{"id":13,"code":"int Api::result()\n{\n    return game_state().player_guess_map[player_->id];\n}","filename":"games/plusminus/src/api.cc","fullname":"Api.result:int()","name":"result"},{"id":14,"code":"void rules_config(rules::Config* cfg)\n    {\n        cfg->name = \"plusminus\";\n        cfg->player_count = 2;\n    }","filename":"games/plusminus/src/entry.cc","fullname":"rules_config","name":"rules_config"},{"id":15,"code":"void rules_init(const rules::Options& opt)\n    {\n        utils::Logger::get().level() = (utils::Logger::DisplayLevel)opt.verbose;\n        rules_ = new Rules(opt);\n    }","filename":"games/plusminus/src/entry.cc","fullname":"rules_init","name":"rules_init"},{"id":16,"code":"void rules_result()\n    {\n        delete rules_;\n    }","filename":"games/plusminus/src/entry.cc","fullname":"rules_result","name":"rules_result"},{"id":17,"code":"void player_loop(rules::ClientMessenger_sptr msgr)\n    {\n        rules_->player_loop(msgr);\n    }","filename":"games/plusminus/src/entry.cc","fullname":"player_loop","name":"player_loop"},{"id":18,"code":"void replay_loop(rules::ReplayMessenger_sptr msgr)\n    {\n        rules_->replay_loop(msgr);\n    }","filename":"games/plusminus/src/entry.cc","fullname":"replay_loop","name":"replay_loop"},{"id":19,"code":"void server_loop(rules::ServerMessenger_sptr msgr)\n    {\n        rules_->server_loop(msgr);\n    }","filename":"games/plusminus/src/entry.cc","fullname":"server_loop","name":"server_loop"},{"id":20,"code":"void spectator_loop(rules::ClientMessenger_sptr msgr)\n    {\n        rules_->spectator_loop(msgr);\n    }","filename":"games/plusminus/src/entry.cc","fullname":"spectator_loop","name":"spectator_loop"},{"id":21,"code":"GameState::GameState(const std::string& map_content,\n                     const rules::Players& players)\n    : rules::GameState(players)\n    , secret_number_found(false)\n    , round(0)\n{\n    std::istringstream map_stream{map_content};\n    map_stream >> secret_number;\n    for (const auto& p : players_)\n        player_guess_map[p->id] = -2; // default value\n}","filename":"games/plusminus/src/game_state.cc","fullname":"GameState.GameState:ANY(ANY,ANY)","name":"GameState"},{"id":22,"code":"GameState* GameState::copy() const\n{\n    return new GameState(*this);\n}","filename":"games/plusminus/src/game_state.cc","fullname":"GameState.copy:GameState*()","name":"copy"},{"id":23,"code":"bool GameState::is_finished() const\n{\n    return secret_number_found || round >= 100;\n}","filename":"games/plusminus/src/game_state.cc","fullname":"GameState.is_finished:bool()","name":"is_finished"},{"id":24,"code":"std::ostream& operator<<(std::ostream& os, const std::vector<T>& arr)\n{\n    os << \"[\";\n    typename std::vector<T>::const_iterator it;\n    for (it = arr.begin(); it != arr.end(); ++it)\n    {\n        if (it != arr.begin())\n            os << \", \";\n        os << *it;\n    }\n    os << \"]\";\n    return os;\n}","filename":"games/plusminus/src/interface.cc","fullname":"<<:ANY(ANY,ANY)","name":"<<"},{"id":25,"code":"std::string convert_to_string(int i)\n{\n    std::ostringstream s;\n    s << i;\n    std::string result = s.str();\n    return result;\n}","filename":"games/plusminus/src/interface.cc","fullname":"convert_to_string:ANY(int)","name":"convert_to_string"},{"id":26,"code":"std::string convert_to_string(double i)\n{\n    std::ostringstream s;\n    s << i;\n    std::string result = s.str();\n    return result;\n}","filename":"games/plusminus/src/interface.cc","fullname":"convert_to_string:ANY(double)","name":"convert_to_string"},{"id":27,"code":"std::string convert_to_string(std::string i)\n{\n    return i;\n}","filename":"games/plusminus/src/interface.cc","fullname":"convert_to_string:ANY(ANY)","name":"convert_to_string"},{"id":28,"code":"std::string convert_to_string(bool i)\n{\n    return i ? \"true\" : \"false\";\n}","filename":"games/plusminus/src/interface.cc","fullname":"convert_to_string:ANY(bool)","name":"convert_to_string"},{"id":29,"code":"std::string convert_to_string(std::vector<int> in)\n{\n    if (in.size())\n    {\n        std::string s = \"[\" + convert_to_string(in[0]);\n        for (int i = 1, l = in.size(); i < l; i++)\n        {\n            s = s + \", \" + convert_to_string(in[i]);\n        }\n        return s + \"]\";\n    }\n    else\n    {\n        return \"[]\";\n    }\n}","filename":"games/plusminus/src/interface.cc","fullname":"convert_to_string:<unresolvedSignature>","name":"convert_to_string"},{"id":30,"code":"std::string convert_to_string(error in)\n{\n    switch (in)\n    {\n    case OK:\n        return \"\\\"ok\\\"\";\n    case OUT_OF_BOUNDS:\n        return \"\\\"out_of_bounds\\\"\";\n    }\n    return \"bad value\";\n}","filename":"games/plusminus/src/interface.cc","fullname":"convert_to_string:ANY(error)","name":"convert_to_string"},{"id":31,"code":"std::string convert_to_string(std::vector<error> in)\n{\n    if (in.size())\n    {\n        std::string s = \"[\" + convert_to_string(in[0]);\n        for (int i = 1, l = in.size(); i < l; i++)\n        {\n            s = s + \", \" + convert_to_string(in[i]);\n        }\n        return s + \"]\";\n    }\n    else\n    {\n        return \"[]\";\n    }\n}","filename":"games/plusminus/src/interface.cc","fullname":"convert_to_string:<unresolvedSignature>","name":"convert_to_string"},{"id":32,"code":"extern \"C\" error api_guess(int guess)\n{\n    return api->guess(guess);\n}","filename":"games/plusminus/src/interface.cc","fullname":"api_guess","name":"api_guess"},{"id":33,"code":"extern \"C\" int api_my_team()\n{\n    return api->my_team();\n}","filename":"games/plusminus/src/interface.cc","fullname":"api_my_team","name":"api_my_team"},{"id":34,"code":"extern \"C\" int api_result()\n{\n    return api->result();\n}","filename":"games/plusminus/src/interface.cc","fullname":"api_result","name":"api_result"},{"id":35,"code":"extern \"C\" bool api_cancel()\n{\n    return api->cancel();\n}","filename":"games/plusminus/src/interface.cc","fullname":"api_cancel","name":"api_cancel"},{"id":36,"code":"std::ostream& operator<<(std::ostream& os, error v)\n{\n    switch (v)\n    {\n    case OK:\n        os << \"OK\";\n        break;\n    case OUT_OF_BOUNDS:\n        os << \"OUT_OF_BOUNDS\";\n        break;\n    }\n    return os;\n}","filename":"games/plusminus/src/interface.cc","fullname":"<<:ANY(ANY,error)","name":"<<"},{"id":37,"code":"extern \"C\" void api_afficher_error(error v)\n{\n    std::cerr << v << std::endl;\n}","filename":"games/plusminus/src/interface.cc","fullname":"api_afficher_error","name":"api_afficher_error"},{"id":38,"code":"ID_ACTION_GUESS, []() { return std::make_unique<ActionGuess>(); });","filename":"games/plusminus/src/rules.cc","fullname":"Rules.register_actions:void().<lambda>0","name":"<lambda>0"},{"id":39,"code":"Rules::Rules(const rules::Options opt)\n    : SynchronousRules(opt)\n    , sandbox_(opt.time)\n{\n    if (!opt.champion_lib.empty())\n    {\n        champion_dll_ = std::make_unique<utils::DLL>(opt.champion_lib);\n\n        champion_init_game_ =\n            champion_dll_->get<f_champion_init_game>(\"init_game\");\n        champion_play_turn_ =\n            champion_dll_->get<f_champion_play_turn>(\"play_turn\");\n        champion_end_game_ =\n            champion_dll_->get<f_champion_end_game>(\"end_game\");\n    }\n\n    if (opt.map_content.empty())\n        FATAL(\"This game requires a map!\");\n\n    auto game_state = std::make_unique<GameState>(opt.map_content, opt.players);\n    api_ = std::make_unique<Api>(std::move(game_state), opt.player);\n    register_actions();\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.Rules:ANY(ANY)","name":"Rules"},{"id":40,"code":"void Rules::register_actions()\n{\n    api_->actions()->register_action(\n        ID_ACTION_GUESS, []() { return std::make_unique<ActionGuess>(); });\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.register_actions:void()","name":"register_actions"},{"id":41,"code":"rules::Actions* Rules::get_actions()\n{\n    return api_->actions();\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.get_actions:ANY()","name":"get_actions"},{"id":42,"code":"void Rules::apply_action(const rules::IAction& action)\n{\n    // When receiving an action, the API should have already checked that it\n    // is valid. We recheck that for the current gamestate here to avoid weird\n    // client/server desynchronizations and make sure the gamestate is always\n    // consistent across the clients and the server.\n\n    int err = api_->game_state_check(action);\n    if (err)\n        FATAL(\"Synchronization error: received action %d from player %d, but \"\n              \"check() on current gamestate returned %d.\",\n              action.id(), action.player_id(), err);\n    api_->game_state_apply(action);\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.apply_action:void(ANY)","name":"apply_action"},{"id":43,"code":"void Rules::at_player_start(rules::ClientMessenger_sptr)\n{\n    try\n    {\n        sandbox_.execute(champion_init_game_);\n    }\n    catch (utils::SandboxTimeout&)\n    {\n        FATAL(\"init_game: timeout\");\n    }\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.at_player_start:void(ANY)","name":"at_player_start"},{"id":44,"code":"void Rules::at_player_end(rules::ClientMessenger_sptr)\n{\n    try\n    {\n        sandbox_.execute(champion_end_game_);\n    }\n    catch (utils::SandboxTimeout&)\n    {\n        FATAL(\"end_game: timeout\");\n    }\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.at_player_end:void(ANY)","name":"at_player_end"},{"id":45,"code":"void Rules::player_turn()\n{\n    try\n    {\n        sandbox_.execute(champion_play_turn_);\n    }\n    catch (utils::SandboxTimeout&)\n    {\n        FATAL(\"play_turn: timeout\");\n    }\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.player_turn:void()","name":"player_turn"},{"id":46,"code":"void Rules::end_of_round()\n{\n    api_->game_state().round += 1;\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.end_of_round:void()","name":"end_of_round"},{"id":47,"code":"void Rules::at_end()\n{\n    for (const auto& p : players_)\n    {\n        auto guess = api_->game_state().player_guess_map[p->id];\n        if (guess == 0)\n            p->score = 1;\n    }\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.at_end:void()","name":"at_end"},{"id":48,"code":"bool Rules::is_finished()\n{\n    return api_->game_state().is_finished();\n}","filename":"games/plusminus/src/rules.cc","fullname":"Rules.is_finished:bool()","name":"is_finished"},{"id":49,"code":"void init_game() {}","filename":"games/tictactoe/champions/cxx/prologin.cc","fullname":"init_game:void()","name":"init_game"},{"id":50,"code":"void play_turn()\n{\n    if (my_team() % 2)\n    {\n        if (turn == 0)\n            play({0, 0});\n        else if (turn == 1)\n            play({2, 0});\n        else if (turn == 2)\n            play({0, 1});\n    }\n    else\n        play({1, turn});\n\n    turn += 1;\n}","filename":"games/tictactoe/champions/cxx/prologin.cc","fullname":"play_turn:void()","name":"play_turn"},{"id":51,"code":"void end_game() {}","filename":"games/tictactoe/champions/cxx/prologin.cc","fullname":"end_game:void()","name":"end_game"},{"id":52,"code":"static inline error play(position pos)\n{\n    return api_play(pos);\n}","filename":"games/tictactoe/champions/cxx/prologin.hh","fullname":"play","name":"play"},{"id":53,"code":"static inline int my_team()\n{\n    return api_my_team();\n}","filename":"games/tictactoe/champions/cxx/prologin.hh","fullname":"my_team","name":"my_team"},{"id":54,"code":"static inline bool cancel()\n{\n    return api_cancel();\n}","filename":"games/tictactoe/champions/cxx/prologin.hh","fullname":"cancel","name":"cancel"},{"id":55,"code":"static inline void afficher_error(error v)\n{\n    api_afficher_error(v);\n}","filename":"games/tictactoe/champions/cxx/prologin.hh","fullname":"afficher_error","name":"afficher_error"},{"id":56,"code":"static inline void afficher_position(position v)\n{\n    api_afficher_position(v);\n}","filename":"games/tictactoe/champions/cxx/prologin.hh","fullname":"afficher_position","name":"afficher_position"},{"id":57,"code":"int ActionPlay::check(const GameState& st) const\n{\n    if (!st.is_valid_cell(pos_))\n        return OUT_OF_BOUNDS;\n    if (st.get_cell(pos_) != st.NO_PLAYER)\n        return ALREADY_OCCUPIED;\n    if (!st.player_can_play(player_id_))\n        return ALREADY_PLAYED;\n\n    return OK;\n}","filename":"games/tictactoe/src/action_play.cc","fullname":"ActionPlay.check:int(GameState &)","name":"check"},{"id":58,"code":"void ActionPlay::apply_on(GameState* st) const\n{\n    st->set_cell(pos_, player_id_);\n    st->set_player_can_play(player_id_, false);\n}","filename":"games/tictactoe/src/action_play.cc","fullname":"ActionPlay.apply_on:void(GameState*)","name":"apply_on"},{"id":59,"code":"Api::Api(std::unique_ptr<GameState> game_state,\n         std::shared_ptr<rules::Player> player)\n    : rules::Api<GameState, error>(std::move(game_state), player)\n{\n    api = this;\n}","filename":"games/tictactoe/src/api.cc","fullname":"Api.Api:ANY(ANY,ANY)","name":"Api"},{"id":60,"code":"int Api::my_team()\n{\n    return player_->id;\n}","filename":"games/tictactoe/src/api.cc","fullname":"Api.my_team:int()","name":"my_team"},{"id":61,"code":"std::vector<int> Api::board()\n{\n    return game_state().get_board();\n}","filename":"games/tictactoe/src/api.cc","fullname":"Api.board:ANY()","name":"board"},{"id":62,"code":"void rules_config(rules::Config* cfg)\n    {\n        cfg->name = \"tictactoe\";\n        cfg->player_count = 2;\n    }","filename":"games/tictactoe/src/entry.cc","fullname":"rules_config","name":"rules_config"},{"id":63,"code":"void rules_init(const rules::Options& opt)\n    {\n        utils::Logger::get().level() = (utils::Logger::DisplayLevel)opt.verbose;\n        rules_ = new Rules(opt);\n    }","filename":"games/tictactoe/src/entry.cc","fullname":"rules_init","name":"rules_init"},{"id":64,"code":"void rules_result()\n    {\n        delete rules_;\n    }","filename":"games/tictactoe/src/entry.cc","fullname":"rules_result","name":"rules_result"},{"id":65,"code":"void player_loop(rules::ClientMessenger_sptr msgr)\n    {\n        rules_->player_loop(msgr);\n    }","filename":"games/tictactoe/src/entry.cc","fullname":"player_loop","name":"player_loop"},{"id":66,"code":"void replay_loop(rules::ReplayMessenger_sptr msgr)\n    {\n        rules_->replay_loop(msgr);\n    }","filename":"games/tictactoe/src/entry.cc","fullname":"replay_loop","name":"replay_loop"},{"id":67,"code":"void server_loop(rules::ServerMessenger_sptr msgr)\n    {\n        rules_->server_loop(msgr);\n    }","filename":"games/tictactoe/src/entry.cc","fullname":"server_loop","name":"server_loop"},{"id":68,"code":"void spectator_loop(rules::ClientMessenger_sptr msgr)\n    {\n        rules_->spectator_loop(msgr);\n    }","filename":"games/tictactoe/src/entry.cc","fullname":"spectator_loop","name":"spectator_loop"},{"id":69,"code":"GameState::GameState(const rules::Players& players)\n    : rules::GameState(players)\n    , board_({NO_PLAYER, NO_PLAYER, NO_PLAYER, NO_PLAYER, NO_PLAYER, NO_PLAYER,\n              NO_PLAYER, NO_PLAYER, NO_PLAYER})\n{\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.GameState:ANY(ANY)","name":"GameState"},{"id":70,"code":"GameState* GameState::copy() const\n{\n    return new GameState(*this);\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.copy:GameState*()","name":"copy"},{"id":71,"code":"std::vector<int> GameState::get_board() const\n{\n    return board_;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.get_board:ANY()","name":"get_board"},{"id":72,"code":"bool GameState::is_valid_cell(position pos) const\n{\n    return 0 <= pos.x && pos.x < 3 && 0 <= pos.y && pos.y < 3;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.is_valid_cell:bool(position)","name":"is_valid_cell"},{"id":73,"code":"int GameState::get_cell(position pos) const\n{\n    if (!is_valid_cell(pos))\n        return NO_PLAYER;\n    return board_[3 * pos.y + pos.x];\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.get_cell:int(position)","name":"get_cell"},{"id":74,"code":"void GameState::set_cell(position pos, int player_id)\n{\n    if (is_valid_cell(pos))\n        board_[3 * pos.y + pos.x] = player_id;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.set_cell:void(position,int)","name":"set_cell"},{"id":75,"code":"int GameState::winner() const\n{\n    // Check rows\n    for (int row = 0; row < 3; row++)\n    {\n        if (get_cell({0, row}) != NO_PLAYER &&\n            get_cell({0, row}) == get_cell({1, row}) &&\n            get_cell({0, row}) == get_cell({2, row}))\n            return get_cell({0, row});\n    }\n\n    // Check columns\n    for (int col = 0; col < 3; col++)\n    {\n        if (get_cell({col, 0}) != NO_PLAYER &&\n            get_cell({col, 0}) == get_cell({col, 1}) &&\n            get_cell({col, 0}) == get_cell({col, 2}))\n            return get_cell({col, 0});\n    }\n\n    // Check diagonals\n    if (get_cell({0, 0}) != NO_PLAYER && get_cell({0, 0}) == get_cell({1, 1}) &&\n        get_cell({0, 0}) == get_cell({2, 2}))\n        return get_cell({0, 0});\n\n    if (get_cell({0, 2}) != NO_PLAYER && get_cell({0, 2}) == get_cell({1, 1}) &&\n        get_cell({0, 2}) == get_cell({2, 0}))\n        return get_cell({0, 2});\n\n    return NO_PLAYER;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.winner:int()","name":"winner"},{"id":76,"code":"bool GameState::is_board_full() const\n{\n    for (int cell : get_board())\n        if (cell == NO_PLAYER)\n            return false;\n    return true;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.is_board_full:bool()","name":"is_board_full"},{"id":77,"code":"bool GameState::is_finished() const\n{\n    return current_player_ == LAST_PLAYER &&\n           (is_board_full() || winner() != NO_PLAYER);\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.is_finished:bool()","name":"is_finished"},{"id":78,"code":"void GameState::compute_scores()\n{\n    auto winner_id = winner();\n    if (winner_id == NO_PLAYER)\n        return;\n    for (const auto& player : players_)\n    {\n        if (player->id == (uint32_t)winner_id)\n        {\n            player->score = 1;\n            break;\n        }\n    }\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.compute_scores:void()","name":"compute_scores"},{"id":79,"code":"void GameState::set_current_player(int player_id)\n{\n    current_player_ = player_id;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.set_current_player:void(int)","name":"set_current_player"},{"id":80,"code":"int GameState::get_current_player() const\n{\n    return current_player_;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.get_current_player:int()","name":"get_current_player"},{"id":81,"code":"void GameState::set_player_can_play(int player_id, bool can_play)\n{\n    player_can_play_.at(player_id) = can_play;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.set_player_can_play:void(int,bool)","name":"set_player_can_play"},{"id":82,"code":"bool GameState::player_can_play(int player_id) const\n{\n    return player_can_play_.at(player_id);\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"GameState.player_can_play:bool(int)","name":"player_can_play"},{"id":83,"code":"std::ostream& operator<<(std::ostream& out, const GameState& gs)\n{\n    for (size_t i = 0; i < gs.get_board().size(); ++i)\n    {\n        if (i % 3 == 0 && i != 0)\n            out << \"\\n\";\n        out << gs.get_board().at(i);\n    }\n\n    out << std::endl;\n\n    return out;\n}","filename":"games/tictactoe/src/game_state.cc","fullname":"<<:ANY(ANY,GameState &)","name":"<<"},{"id":84,"code":"std::ostream& operator<<(std::ostream& os, const std::vector<T>& arr)\n{\n    os << \"[\";\n    typename std::vector<T>::const_iterator it;\n    for (it = arr.begin(); it != arr.end(); ++it)\n    {\n        if (it != arr.begin())\n            os << \", \";\n        os << *it;\n    }\n    os << \"]\";\n    return os;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"<<:ANY(ANY,ANY)","name":"<<"},{"id":85,"code":"std::string convert_to_string(int i)\n{\n    std::ostringstream s;\n    s << i;\n    std::string result = s.str();\n    return result;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:ANY(int)","name":"convert_to_string"},{"id":86,"code":"std::string convert_to_string(double i)\n{\n    std::ostringstream s;\n    s << i;\n    std::string result = s.str();\n    return result;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:ANY(double)","name":"convert_to_string"},{"id":87,"code":"std::string convert_to_string(std::string i)\n{\n    return i;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:ANY(ANY)","name":"convert_to_string"},{"id":88,"code":"std::string convert_to_string(bool i)\n{\n    return i ? \"true\" : \"false\";\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:ANY(bool)","name":"convert_to_string"},{"id":89,"code":"std::string convert_to_string(std::vector<int> in)\n{\n    if (in.size())\n    {\n        std::string s = \"[\" + convert_to_string(in[0]);\n        for (int i = 1, l = in.size(); i < l; i++)\n        {\n            s = s + \", \" + convert_to_string(in[i]);\n        }\n        return s + \"]\";\n    }\n    else\n    {\n        return \"[]\";\n    }\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:<unresolvedSignature>","name":"convert_to_string"},{"id":90,"code":"std::string convert_to_string(error in)\n{\n    switch (in)\n    {\n    case OK:\n        return \"\\\"ok\\\"\";\n    case OUT_OF_BOUNDS:\n        return \"\\\"out_of_bounds\\\"\";\n    case ALREADY_OCCUPIED:\n        return \"\\\"already_occupied\\\"\";\n    case ALREADY_PLAYED:\n        return \"\\\"already_played\\\"\";\n    }\n    return \"bad value\";\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:ANY(error)","name":"convert_to_string"},{"id":91,"code":"std::string convert_to_string(std::vector<error> in)\n{\n    if (in.size())\n    {\n        std::string s = \"[\" + convert_to_string(in[0]);\n        for (int i = 1, l = in.size(); i < l; i++)\n        {\n            s = s + \", \" + convert_to_string(in[i]);\n        }\n        return s + \"]\";\n    }\n    else\n    {\n        return \"[]\";\n    }\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:<unresolvedSignature>","name":"convert_to_string"},{"id":92,"code":"std::string convert_to_string(position in)\n{\n    std::string x = convert_to_string(in.x);\n    std::string y = convert_to_string(in.y);\n    std::string out = \"{\";\n    out += \"x:\" + x;\n    out += \", \";\n    out += \"y:\" + y;\n    return out + \"}\";\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:ANY(position)","name":"convert_to_string"},{"id":93,"code":"std::string convert_to_string(std::vector<position> in)\n{\n    if (in.size())\n    {\n        std::string s = \"[\" + convert_to_string(in[0]);\n        for (int i = 1, l = in.size(); i < l; i++)\n        {\n            s = s + \", \" + convert_to_string(in[i]);\n        }\n        return s + \"]\";\n    }\n    else\n    {\n        return \"[]\";\n    }\n}","filename":"games/tictactoe/src/interface.cc","fullname":"convert_to_string:<unresolvedSignature>","name":"convert_to_string"},{"id":94,"code":"extern \"C\" error api_play(position pos)\n{\n    return api->play(pos);\n}","filename":"games/tictactoe/src/interface.cc","fullname":"api_play","name":"api_play"},{"id":95,"code":"extern \"C\" int api_my_team()\n{\n    return api->my_team();\n}","filename":"games/tictactoe/src/interface.cc","fullname":"api_my_team","name":"api_my_team"},{"id":96,"code":"extern \"C\" std::vector<int> api_board()\n{\n    return api->board();\n}","filename":"games/tictactoe/src/interface.cc","fullname":"api_board","name":"api_board"},{"id":97,"code":"extern \"C\" bool api_cancel()\n{\n    return api->cancel();\n}","filename":"games/tictactoe/src/interface.cc","fullname":"api_cancel","name":"api_cancel"},{"id":98,"code":"std::ostream& operator<<(std::ostream& os, error v)\n{\n    switch (v)\n    {\n    case OK:\n        os << \"OK\";\n        break;\n    case OUT_OF_BOUNDS:\n        os << \"OUT_OF_BOUNDS\";\n        break;\n    case ALREADY_OCCUPIED:\n        os << \"ALREADY_OCCUPIED\";\n        break;\n    case ALREADY_PLAYED:\n        os << \"ALREADY_PLAYED\";\n        break;\n    }\n    return os;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"<<:ANY(ANY,error)","name":"<<"},{"id":99,"code":"extern \"C\" void api_afficher_error(error v)\n{\n    std::cerr << v << std::endl;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"api_afficher_error","name":"api_afficher_error"},{"id":100,"code":"std::ostream& operator<<(std::ostream& os, position v)\n{\n    os << \"{ \";\n    os << \"x\"\n       << \"=\" << v.x;\n    os << \", \";\n    os << \"y\"\n       << \"=\" << v.y;\n    os << \" }\";\n    return os;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"<<:ANY(ANY,position)","name":"<<"},{"id":101,"code":"extern \"C\" void api_afficher_position(position v)\n{\n    std::cerr << v << std::endl;\n}","filename":"games/tictactoe/src/interface.cc","fullname":"api_afficher_position","name":"api_afficher_position"},{"id":102,"code":"ID_ACTION_PLAY, []() { return std::make_unique<ActionPlay>(); });","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.register_actions:void().<lambda>0","name":"<lambda>0"},{"id":103,"code":"Rules::Rules(const rules::Options opt)\n    : TurnBasedRules(opt)\n    , sandbox_(opt.time)\n{\n    if (!opt.champion_lib.empty())\n    {\n        champion_dll_ = std::make_unique<utils::DLL>(opt.champion_lib);\n\n        champion_init_game_ =\n            champion_dll_->get<f_champion_init_game>(\"init_game\");\n        champion_play_turn_ =\n            champion_dll_->get<f_champion_play_turn>(\"play_turn\");\n        champion_end_game_ =\n            champion_dll_->get<f_champion_end_game>(\"end_game\");\n    }\n\n    auto game_state = std::make_unique<GameState>(opt.players);\n    api_ = std::make_unique<Api>(std::move(game_state), opt.player);\n    register_actions();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.Rules:ANY(ANY)","name":"Rules"},{"id":104,"code":"void Rules::register_actions()\n{\n    api_->actions()->register_action(\n        ID_ACTION_PLAY, []() { return std::make_unique<ActionPlay>(); });\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.register_actions:void()","name":"register_actions"},{"id":105,"code":"rules::Actions* Rules::get_actions()\n{\n    return api_->actions();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.get_actions:ANY()","name":"get_actions"},{"id":106,"code":"void Rules::apply_action(const rules::IAction& action)\n{\n    // When receiving an action, the API should have already checked that it\n    // is valid. We recheck that for the current gamestate here to avoid weird\n    // client/server desynchronizations and make sure the gamestate is always\n    // consistent across the clients and the server.\n\n    int err = api_->game_state_check(action);\n    if (err)\n        FATAL(\"Synchronization error: received action %d from player %d, but \"\n              \"check() on current gamestate returned %d.\",\n              action.id(), action.player_id(), err);\n    api_->game_state_apply(action);\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.apply_action:void(ANY)","name":"apply_action"},{"id":107,"code":"void Rules::at_player_start(rules::ClientMessenger_sptr)\n{\n    try\n    {\n        sandbox_.execute(champion_init_game_);\n    }\n    catch (utils::SandboxTimeout&)\n    {\n        FATAL(\"player_start: timeout\");\n    }\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.at_player_start:void(ANY)","name":"at_player_start"},{"id":108,"code":"void Rules::at_spectator_start(rules::ClientMessenger_sptr)\n{\n    champion_init_game_();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.at_spectator_start:void(ANY)","name":"at_spectator_start"},{"id":109,"code":"void Rules::at_player_end(rules::ClientMessenger_sptr)\n{\n    try\n    {\n        sandbox_.execute(champion_end_game_);\n    }\n    catch (utils::SandboxTimeout&)\n    {\n        FATAL(\"player_end: timeout\");\n    }\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.at_player_end:void(ANY)","name":"at_player_end"},{"id":110,"code":"void Rules::at_spectator_end(rules::ClientMessenger_sptr)\n{\n    champion_end_game_();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.at_spectator_end:void(ANY)","name":"at_spectator_end"},{"id":111,"code":"void Rules::player_turn()\n{\n    try\n    {\n        sandbox_.execute(champion_play_turn_);\n    }\n    catch (utils::SandboxTimeout&)\n    {\n        FATAL(\"player_turn: timeout\");\n    }\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.player_turn:void()","name":"player_turn"},{"id":112,"code":"void Rules::spectator_turn()\n{\n    champion_play_turn_();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.spectator_turn:void()","name":"spectator_turn"},{"id":113,"code":"void Rules::start_of_player_turn(unsigned int player_id)\n{\n    api_->game_state().set_current_player(player_id);\n    api_->game_state().set_player_can_play(player_id, true);\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.start_of_player_turn:void(unsigned int)","name":"start_of_player_turn"},{"id":114,"code":"void Rules::end_of_player_turn(unsigned int player_id)\n{\n    // Clear the list of game states at the end of each turn (half-round)\n    // We need the linked list of game states only for undo and history,\n    // therefore old states are not needed anymore after the turn ends.\n    api_->clear_old_game_states();\n    api_->game_state().set_player_can_play(player_id, false);\n    api_->game_state().compute_scores();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.end_of_player_turn:void(unsigned int)","name":"end_of_player_turn"},{"id":115,"code":"bool Rules::is_finished()\n{\n    return api_->game_state().is_finished();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.is_finished:bool()","name":"is_finished"},{"id":116,"code":"GameState& Rules::game_state()\n{\n    return api_->game_state();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.game_state:GameState &()","name":"game_state"},{"id":117,"code":"const GameState& Rules::game_state() const\n{\n    return api_->game_state();\n}","filename":"games/tictactoe/src/rules.cc","fullname":"Rules.game_state:GameState &()","name":"game_state"},{"id":118,"code":"Client::Client()\n{\n    rules_lib_ = std::make_unique<utils::DLL>(FLAGS_rules);\n\n    // Get required functions from the rules library\n    rules_init = rules_lib_->get<rules::f_rules_init>(\"rules_init\");\n    rules_result = rules_lib_->get<rules::f_rules_result>(\"rules_result\");\n\n    if (FLAGS_spectator)\n        client_loop = rules_lib_->get<rules::f_client_loop>(\"spectator_loop\");\n    else\n        client_loop = rules_lib_->get<rules::f_client_loop>(\"player_loop\");\n}","filename":"src/client/client.cc","fullname":"Client.Client:ANY()","name":"Client"},{"id":119,"code":"void Client::run()\n{\n    // Register to the stechec2 server\n    sckt_init();\n\n    // Wait for the players list to be sent by the server\n    wait_for_players();\n\n    // Create a messenger for sending rules messages\n    msgr_ = std::make_unique<rules::ClientMessenger>(sckt_.get(), player_->id);\n\n    // Load map, if given\n    auto map_content = rules::read_map_from_path(FLAGS_map);\n\n    // Set the rules options\n    rules::Options rules_opt;\n    rules_opt.champion_lib = FLAGS_champion;\n    rules_opt.time = FLAGS_time;\n    rules_opt.map_file = FLAGS_map;\n    rules_opt.map_content = map_content;\n    rules_opt.player = player_;\n    rules_opt.verbose = FLAGS_verbose;\n    rules_opt.players = players_;\n    rules_opt.spectators = spectators_;\n\n    // Rules specific initializations\n    rules_init(rules_opt);\n\n    // Wait for the server ACK to start the game\n    wait_for_game_start();\n\n    // Play the game\n    client_loop(msgr_);\n\n    // Results\n    rules_result();\n\n    sckt_close();\n}","filename":"src/client/client.cc","fullname":"Client.run:void()","name":"run"},{"id":120,"code":"void Client::sckt_init()\n{\n    sckt_ = std::make_unique<net::ClientSocket>(FLAGS_sub_addr, FLAGS_req_addr);\n    sckt_->init();\n\n    NOTICE(\"Requesting on %s\", FLAGS_req_addr.c_str());\n    NOTICE(\"Subscribing on %s\", FLAGS_sub_addr.c_str());\n\n    // Compute the client type\n    uint32_t client_type;\n    if (FLAGS_spectator)\n        client_type = rules::SPECTATOR;\n    else\n        client_type = rules::PLAYER;\n\n    // Send a message to announce or get an id from the server\n    utils::Buffer buf_req;\n    net::Message msg(net::MSG_CONNECT, FLAGS_client_id);\n\n    msg.handle_buffer(buf_req);\n    buf_req.handle(client_type);\n    buf_req.handle(FLAGS_name);\n\n    // Send the request\n    std::unique_ptr<utils::Buffer> buf_rep;\n    if (!sckt_->send(buf_req) || !(buf_rep = sckt_->recv()) ||\n        (msg.handle_buffer(*buf_rep), msg.client_id == -1))\n        FATAL(\"Unable to get an ID from the server\");\n\n    player_ = std::make_shared<rules::Player>(msg.client_id, client_type);\n    player_->name = FLAGS_name;\n\n    NOTICE(\"Connected - id: %i\", player_->id);\n}","filename":"src/client/client.cc","fullname":"Client.sckt_init:void()","name":"sckt_init"},{"id":121,"code":"void Client::sckt_close()\n{\n    sckt_->close();\n}","filename":"src/client/client.cc","fullname":"Client.sckt_close:void()","name":"sckt_close"},{"id":122,"code":"void Client::wait_for_players()\n{\n    net::Message msg;\n\n    // Wait for players\n    uint32_t msg_type = net::MSG_IGNORED;\n    while (msg_type != net::MSG_PLAYERS)\n    {\n        auto buf = sckt_->pull();\n        msg.handle_buffer(*buf);\n\n        if ((msg_type = msg.type) == net::MSG_PLAYERS)\n            players_.handle_buffer(*buf);\n    }\n\n    // Wait for spectators\n    msg_type = net::MSG_IGNORED;\n    while (msg_type != net::MSG_PLAYERS)\n    {\n        auto buf = sckt_->pull();\n        msg.handle_buffer(*buf);\n\n        if ((msg_type = msg.type) == net::MSG_PLAYERS)\n            spectators_.handle_buffer(*buf);\n    }\n}","filename":"src/client/client.cc","fullname":"Client.wait_for_players:void()","name":"wait_for_players"},{"id":123,"code":"void Client::wait_for_game_start()\n{\n    net::Message msg;\n    uint32_t msg_type = net::MSG_IGNORED;\n\n    while (msg_type != net::MSG_GAMESTART)\n    {\n        auto buf = sckt_->pull();\n        msg.handle_buffer(*buf);\n        msg_type = msg.type;\n    }\n}","filename":"src/client/client.cc","fullname":"Client.wait_for_game_start:void()","name":"wait_for_game_start"},{"id":124,"code":"int main(int argc, char** argv)\n{\n    GFLAGS_NAMESPACE::ParseCommandLineFlags(&argc, &argv, true);\n\n    Client client;\n    client.run();\n}","filename":"src/client/main.cc","fullname":"main:int(int,char**)","name":"main"},{"id":125,"code":"ClientSocket::ClientSocket(const std::string& sub_addr,\n                           const std::string& req_addr)\n    : Socket(sub_addr, req_addr, 1)\n{\n}","filename":"src/lib/net/client-socket.cc","fullname":"net.ClientSocket.ClientSocket:ANY(ANY,ANY)","name":"ClientSocket"},{"id":126,"code":"void ClientSocket::init()\n{\n    try\n    {\n        pubsub_sckt_ = std::make_unique<zmq::socket_t>(ctx_, ZMQ_SUB);\n        pubsub_sckt_->connect(pubsub_addr_.c_str());\n        pubsub_sckt_->setsockopt(ZMQ_SUBSCRIBE, nullptr, 0);\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"SUB: %s: %s\", pubsub_addr_.c_str(), e.what());\n    }\n\n    try\n    {\n        reqrep_sckt_ = std::make_unique<zmq::socket_t>(ctx_, ZMQ_REQ);\n        reqrep_sckt_->connect(reqrep_addr_.c_str());\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"REQ: %s: %s\", reqrep_addr_.c_str(), e.what());\n    }\n\n    shared_init();\n}","filename":"src/lib/net/client-socket.cc","fullname":"net.ClientSocket.init:void()","name":"init"},{"id":127,"code":"void ClientSocket::close()\n{\n    try\n    {\n        pubsub_sckt_->close();\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"SUB: close: %s\", e.what());\n    }\n\n    try\n    {\n        reqrep_sckt_->close();\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"REQ: close: %s\", e.what());\n    }\n}","filename":"src/lib/net/client-socket.cc","fullname":"net.ClientSocket.close:void()","name":"close"},{"id":128,"code":"std::unique_ptr<utils::Buffer> ClientSocket::pull(int flags)\n{\n    return recv_sckt(pubsub_sckt_.get(), flags);\n}","filename":"src/lib/net/client-socket.cc","fullname":"net.ClientSocket.pull:ANY(int)","name":"pull"},{"id":129,"code":"Message::Message(uint32_t type, uint32_t client_id)\n    : type(type)\n    , client_id(client_id)\n{\n}","filename":"src/lib/net/message.cc","fullname":"net.Message.Message:ANY(ANY,ANY)","name":"Message"},{"id":130,"code":"std::string Message::str() const\n{\n    std::stringstream ss;\n\n    ss << \"type      : \" << type << \"\\n\"\n       << \"client_id : \" << client_id;\n\n    return ss.str();\n}","filename":"src/lib/net/message.cc","fullname":"net.Message.str:ANY()","name":"str"},{"id":131,"code":"std::ostream& operator<<(std::ostream& os, const net::Message& msg)\n{\n    os << msg.str() << std::endl;\n\n    return os;\n}","filename":"src/lib/net/message.cc","fullname":"<<:ANY(ANY,net.Message&)","name":"<<"},{"id":132,"code":"ServerSocket::ServerSocket(const std::string& pub_addr,\n                           const std::string& rep_addr)\n    : Socket(pub_addr, rep_addr, 2)\n{\n}","filename":"src/lib/net/server-socket.cc","fullname":"net.ServerSocket.ServerSocket:ANY(ANY,ANY)","name":"ServerSocket"},{"id":133,"code":"void ServerSocket::init()\n{\n    // We want to create the domain sockets with mode 777 to allow users from\n    // different processes to communicate with us.\n    mode_t old_umask = umask(0);\n\n    try\n    {\n        pubsub_sckt_ = std::make_unique<zmq::socket_t>(ctx_, ZMQ_PUB);\n        pubsub_sckt_->bind(pubsub_addr_.c_str());\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"PUB: %s: %s\", pubsub_addr_.c_str(), e.what());\n    }\n\n    try\n    {\n        reqrep_sckt_ = std::make_unique<zmq::socket_t>(ctx_, ZMQ_REP);\n        reqrep_sckt_->bind(reqrep_addr_.c_str());\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"REP: %s: %s\", reqrep_addr_.c_str(), e.what());\n    }\n\n    // Restore the process umask\n    umask(old_umask);\n\n    shared_init();\n}","filename":"src/lib/net/server-socket.cc","fullname":"net.ServerSocket.init:void()","name":"init"},{"id":134,"code":"void ServerSocket::close()\n{\n    try\n    {\n        pubsub_sckt_->close();\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"SUB: close: %s\", e.what());\n    }\n\n    try\n    {\n        reqrep_sckt_->close();\n    }\n    catch (const zmq::error_t& e)\n    {\n        FATAL(\"REQ: close: %s\", e.what());\n    }\n}","filename":"src/lib/net/server-socket.cc","fullname":"net.ServerSocket.close:void()","name":"close"},{"id":135,"code":"bool ServerSocket::push(const utils::Buffer& buf, int flags, size_t sleep)\n{\n    if (sleep)\n        std::this_thread::sleep_for(std::chrono::milliseconds(sleep));\n    return send_sckt(buf, pubsub_sckt_.get(), flags);\n}","filename":"src/lib/net/server-socket.cc","fullname":"net.ServerSocket.push:bool(ANY,int,ANY)","name":"push"},{"id":136,"code":"Socket::Socket(const std::string& pubsub_addr, const std::string& reqrep_addr,\n               int io_thread)\n    : pubsub_addr_(pubsub_addr)\n    , reqrep_addr_(reqrep_addr)\n    , ctx_(io_thread)\n    , pubsub_sckt_()\n    , reqrep_sckt_()\n{\n}","filename":"src/lib/net/socket.cc","fullname":"net.Socket.Socket:ANY(ANY,ANY,int)","name":"Socket"},{"id":137,"code":"void Socket::shared_init()\n{\n    int timeout = FLAGS_socket_timeout;\n    if (timeout != -1)\n    {\n        pubsub_sckt_->setsockopt(ZMQ_RCVTIMEO, &timeout, sizeof(timeout));\n        reqrep_sckt_->setsockopt(ZMQ_RCVTIMEO, &timeout, sizeof(timeout));\n    }\n}","filename":"src/lib/net/socket.cc","fullname":"net.Socket.shared_init:void()","name":"shared_init"},{"id":138,"code":"bool Socket::send(const utils::Buffer& msg, int flags)\n{\n    return send_sckt(msg, reqrep_sckt_.get(), flags);\n}","filename":"src/lib/net/socket.cc","fullname":"net.Socket.send:bool(ANY,int)","name":"send"},{"id":139,"code":"std::unique_ptr<utils::Buffer> Socket::recv(int flags)\n{\n    return recv_sckt(reqrep_sckt_.get(), flags);\n}","filename":"src/lib/net/socket.cc","fullname":"net.Socket.recv:ANY(int)","name":"recv"},{"id":140,"code":"bool Socket::poll(long timeout)\n{\n    zmq::pollitem_t pollitem;\n    pollitem.socket = static_cast<void*>(*reqrep_sckt_);\n    pollitem.events = ZMQ_POLLIN;\n\n    return zmq::poll(&pollitem, 1, timeout) > 0;\n}","filename":"src/lib/net/socket.cc","fullname":"net.Socket.poll:bool(long int)","name":"poll"},{"id":141,"code":"bool Socket::send_sckt(const utils::Buffer& buf, zmq::socket_t* sckt, int flags)\n{\n    try\n    {\n        while (true)\n            try\n            {\n                if (!sckt->send(buf.data(), buf.size(), flags))\n                    throw std::runtime_error(\"Could not send message\");\n                break;\n            }\n            catch (const zmq::error_t& e)\n            {\n                if (e.num() == EINTR)\n                    continue;\n                throw;\n            }\n        return true;\n    }\n    catch (const std::exception& e)\n    {\n        ERR(\"%s\", e.what());\n        return false;\n    }\n}","filename":"src/lib/net/socket.cc","fullname":"net.Socket.send_sckt:bool(ANY,ANY,int)","name":"send_sckt"},{"id":142,"code":"std::unique_ptr<utils::Buffer> Socket::recv_sckt(zmq::socket_t* sckt, int flags)\n{\n    try\n    {\n        zmq::message_t zmsg;\n        while (true)\n            try\n            {\n                if (!sckt->recv(&zmsg, flags))\n                    throw std::runtime_error(\"Could not get message\");\n                break;\n            }\n            catch (const zmq::error_t& e)\n            {\n                if (e.num() == EINTR)\n                    continue;\n                throw;\n            }\n\n        std::vector<uint8_t> data;\n        data.assign(reinterpret_cast<uint8_t*>(zmsg.data()),\n                    reinterpret_cast<uint8_t*>(zmsg.data()) + zmsg.size());\n\n        return std::make_unique<utils::Buffer>(data);\n    }\n    catch (const std::exception& e)\n    {\n        ERR(\"%s\", e.what());\n        return nullptr;\n    }\n}","filename":"src/lib/net/socket.cc","fullname":"net.Socket.recv_sckt:ANY(ANY,int)","name":"recv_sckt"},{"id":143,"code":"void Actions::handle_buffer(utils::Buffer& buf)\n{\n    if (buf.serialize())\n    {\n        for (const auto& action : actions_)\n        {\n            // The id is needed to reconstruct the action when unserializing\n            uint32_t action_id = action->id();\n            buf.handle(action_id);\n\n            action->handle_buffer(buf);\n        }\n    }\n    else\n    {\n        while (!buf.empty())\n        {\n            // Get the action id\n            uint32_t action_id;\n            buf.handle(action_id);\n\n            // Use it to instantiate the right rules Action\n            if (action_factory_.find(action_id) == action_factory_.end())\n                FATAL(\"Action %d isn't registered\", action_id);\n            auto action = action_factory_[action_id]();\n\n            // And finally unserialize\n            action->handle_buffer(buf);\n            actions_.push_back(std::move(action));\n        }\n    }\n}","filename":"src/lib/rules/actions.cc","fullname":"rules.Actions.handle_buffer:void(ANY)","name":"handle_buffer"},{"id":144,"code":"void Actions::register_action(uint32_t action_id, ActionFactory action_factory)\n{\n    action_factory_[action_id] = std::move(action_factory);\n}","filename":"src/lib/rules/actions.cc","fullname":"rules.Actions.register_action:void(ANY,ANY)","name":"register_action"},{"id":145,"code":"ClientMessenger::ClientMessenger(net::ClientSocket* sckt, uint32_t client_id)\n    : sckt_(sckt)\n    , client_id_(client_id)\n{\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.ClientMessenger:ANY(ANY,ANY)","name":"ClientMessenger"},{"id":146,"code":"void ClientMessenger::send(const utils::Buffer& buf)\n{\n    utils::Buffer out_buf;\n    net::Message msg(net::MSG_RULES, client_id_);\n\n    msg.handle_buffer(out_buf);\n    out_buf += buf;\n\n    if (!sckt_->send(out_buf))\n        FATAL(\"Unable to send message to server\");\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.send:void(ANY)","name":"send"},{"id":147,"code":"void ClientMessenger::send_actions(Actions& actions)\n{\n    utils::Buffer buf;\n    actions.handle_buffer(buf);\n    send(buf);\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.send_actions:void(rules.Actions&)","name":"send_actions"},{"id":148,"code":"std::unique_ptr<utils::Buffer> ClientMessenger::recv()\n{\n    auto buf = sckt_->recv();\n    if (!buf)\n        FATAL(\"Unable to receive message from server\");\n\n    net::Message msg;\n    msg.handle_buffer(*buf);\n\n    return buf;\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.recv:ANY()","name":"recv"},{"id":149,"code":"std::unique_ptr<utils::Buffer> ClientMessenger::pull()\n{\n    auto buf = sckt_->pull();\n\n    net::Message msg;\n    msg.handle_buffer(*buf);\n\n    return buf;\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.pull:ANY()","name":"pull"},{"id":150,"code":"void ClientMessenger::pull_actions(Actions* actions)\n{\n    actions->handle_buffer(*pull());\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.pull_actions:void(rules.Actions*)","name":"pull_actions"},{"id":151,"code":"void ClientMessenger::pull_id(uint32_t* id)\n{\n    pull()->handle(*id);\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.pull_id:void(ANY)","name":"pull_id"},{"id":152,"code":"void ClientMessenger::ack()\n{\n    utils::Buffer buf;\n    net::Message msg(net::MSG_ACK);\n\n    msg.handle_buffer(buf);\n\n    if (!sckt_->send(buf))\n        FATAL(\"Unable to send ack to server\");\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.ack:void()","name":"ack"},{"id":153,"code":"void ClientMessenger::wait_for_ack()\n{\n    auto buf = sckt_->recv();\n    if (!buf)\n        FATAL(\"Unable to receive ack from server\");\n\n    net::Message msg;\n    msg.handle_buffer(*buf);\n\n    CHECK_EXC(ClientMessengerError, msg.type == net::MSG_ACK);\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.wait_for_ack:void()","name":"wait_for_ack"},{"id":154,"code":"bool ClientMessenger::wait_for_turn(uint32_t player_id, uint32_t* pulled_id)\n{\n    pull_id(pulled_id);\n\n    return player_id != *pulled_id;\n}","filename":"src/lib/rules/client-messenger.cc","fullname":"rules.ClientMessenger.wait_for_turn:bool(ANY,ANY)","name":"wait_for_turn"},{"id":155,"code":"std::string read_map_from_path(const std::string& path)\n{\n    if (path.empty())\n        return {};\n    std::ifstream ifs{path};\n    if (!ifs.is_open())\n        FATAL(\"Cannot open map file: %s\", path.c_str());\n    std::string map_content((std::istreambuf_iterator<char>(ifs)),\n                            std::istreambuf_iterator<char>());\n    return map_content;\n}","filename":"src/lib/rules/options.cc","fullname":"rules.read_map_from_path:ANY(ANY)","name":"read_map_from_path"},{"id":156,"code":"void ReplayMessenger::pull_id(uint32_t* player_id)\n{\n    buf_->handle(*player_id);\n}","filename":"src/lib/rules/replay-messenger.cc","fullname":"rules.ReplayMessenger.pull_id:void(ANY)","name":"pull_id"},{"id":157,"code":"void ReplayMessenger::pull_actions(Actions* actions)\n{\n    buf_->handle_bufferizable(actions);\n}","filename":"src/lib/rules/replay-messenger.cc","fullname":"rules.ReplayMessenger.pull_actions:void(rules.Actions*)","name":"pull_actions"},{"id":158,"code":"Rules::Rules(const Options& opt)\n    : opt_(opt)\n    , players_(opt.players)\n    , spectators_(opt.spectators)\n    , timeout_(opt.time)\n{\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.Rules.Rules:ANY(rules.Options&)","name":"Rules"},{"id":159,"code":"void Rules::save_player_actions(Actions* actions)\n{\n    if (!opt_.replay_stream)\n        return;\n    utils::Buffer buf;\n    buf.handle_bufferizable(actions);\n    *opt_.replay_stream << buf;\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.Rules.save_player_actions:void(rules.Actions*)","name":"save_player_actions"},{"id":160,"code":"bool Rules::is_spectator(uint32_t id)\n{\n    for (const auto& spectator : spectators_)\n        if (spectator->id == id)\n            return true;\n\n    return false;\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.Rules.is_spectator:bool(ANY)","name":"is_spectator"},{"id":161,"code":"void Rules::write_stats() const\n{\n    if (FLAGS_stats.empty())\n        return;\n\n    std::ofstream ofs(FLAGS_stats);\n    if (!ofs.is_open())\n        FATAL(\"Cannot open stats file for writing %s: %s\", FLAGS_stats.c_str(),\n              strerror(errno));\n\n    // Write generic stats\n    ofs << \"- metrics:\\n\";\n    for (const auto& item : metrics_)\n        ofs << \"  - \" << item.first << \": \" << item.second << '\\n';\n\n    // Write stats about players\n    for (const auto& player : players_)\n    {\n        ofs << \"- player:\\n\"\n            << \"  - id: \" << player->id << '\\n'\n            << \"  - name: \" << player->name << '\\n';\n\n        // Turn durations will be empty for the opponent players in player\n        // loops.\n        if (!player->turn_duration_ms.empty())\n        {\n            ofs << \"  - turn_duration_ms:\" << '\\n';\n            for (const auto duration : player->turn_duration_ms)\n                ofs << \"    - \" << duration << '\\n';\n        }\n    }\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.Rules.write_stats:void()","name":"write_stats"},{"id":162,"code":"SynchronousRules::SynchronousRules(const Options& opt)\n    : Rules(opt)\n{\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.SynchronousRules.SynchronousRules:ANY(rules.Options&)","name":"SynchronousRules"},{"id":163,"code":"void SynchronousRules::player_loop(ClientMessenger_sptr msgr)\n{\n    at_start();\n    at_player_start(msgr);\n\n    while (!is_finished())\n    {\n        start_of_round();\n        Actions* actions = get_actions();\n        actions->clear();\n\n        player_turn();\n        msgr->send_actions(*actions);\n        msgr->wait_for_ack();\n        actions->clear();\n\n        msgr->pull_actions(actions);\n\n        /* Apply actions onto the gamestate */\n        /* We should already have applied our actions */\n        for (const auto& action : actions->all())\n            if (action->player_id() != opt_.player->id)\n                apply_action(*action);\n\n        end_of_round();\n    }\n\n    at_end();\n    at_player_end(msgr);\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.SynchronousRules.player_loop:void(ANY)","name":"player_loop"},{"id":164,"code":"void SynchronousRules::replay_loop(ReplayMessenger_sptr msgr)\n{\n    at_start();\n\n    auto actions = get_actions();\n    while (!is_finished())\n    {\n        start_of_round();\n\n        msgr->pull_actions(actions);\n        for (const auto& action : actions->all())\n            apply_action(*action);\n        actions->clear();\n\n        end_of_round();\n    }\n\n    at_end();\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.SynchronousRules.replay_loop:void(ANY)","name":"replay_loop"},{"id":165,"code":"void SynchronousRules::spectator_loop(ClientMessenger_sptr msgr)\n{\n    at_start();\n    at_spectator_start(msgr);\n\n    // FIXME(seirl): unused, last round missing?\n    bool last_round = false;\n\n    while (last_round || !is_finished())\n    {\n        start_of_round();\n        Actions* actions = get_actions();\n        actions->clear();\n\n        spectator_turn();\n        msgr->send_actions(*actions);\n        msgr->wait_for_ack();\n        actions->clear();\n\n        if (last_round)\n            break;\n\n        msgr->pull_actions(actions);\n        for (const auto& action : actions->all())\n            apply_action(*action);\n        actions->clear();\n\n        end_of_round();\n    }\n\n    at_end();\n    at_spectator_end(msgr);\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.SynchronousRules.spectator_loop:void(ANY)","name":"spectator_loop"},{"id":166,"code":"void SynchronousRules::server_loop(ServerMessenger_sptr msgr)\n{\n    std::unordered_set<uint32_t> spectators_ids;\n    for (const auto& spectator : spectators_)\n        spectators_ids.insert(spectator->id);\n\n    std::unordered_set<uint32_t> players_ids;\n    for (const auto& player : players_)\n        players_ids.insert(player->id);\n    for (const auto& spectator : spectators_)\n        players_ids.insert(spectator->id);\n\n    std::set<uint32_t> players_timeouting;\n    unsigned int players_count = players_.size() + spectators_.size();\n\n    at_start();\n    at_server_start(msgr);\n\n    dump_state_stream();\n\n    while (!is_finished())\n    {\n        auto round_start = std::chrono::high_resolution_clock::now();\n\n        auto spectators_count = spectators_.size();\n        start_of_round();\n\n        auto actions = get_actions();\n        actions->clear();\n\n        players_timeouting.clear();\n        for (const auto& player : players_)\n            players_timeouting.insert(player->id);\n\n        for (size_t i = 0; i < players_count; ++i)\n        {\n            if (!msgr->poll(timeout_ > 0 ? timeout_ : -1))\n                break;\n\n            // Ignore revived players\n            do\n            {\n                msgr->recv_actions(actions);\n                msgr->ack();\n            } while (players_ids.find(msgr->last_client_id()) ==\n                     players_ids.end());\n\n            unsigned player_id = msgr->last_client_id();\n            if (spectators_ids.find(player_id) != spectators_ids.end())\n                spectators_count--;\n            else\n                players_timeouting.erase(player_id);\n        }\n\n        // Increase timeout count for players that did not answer in time\n        for (const auto& player : players_)\n        {\n            if (players_timeouting.find(player->id) != players_timeouting.end())\n            {\n                player->nb_timeout += 1;\n                if (player->nb_timeout == 3)\n                {\n                    players_ids.erase(player->id);\n                    players_count--;\n                }\n            }\n        }\n\n        // No timeout for spectators\n        while (spectators_count > 0)\n        {\n            msgr->recv_actions(actions);\n            msgr->ack();\n            spectators_count--;\n        }\n\n        metrics_[\"actions_total\"] += actions->size();\n        save_player_actions(actions);\n\n        for (const auto& action : actions->all())\n            apply_action(*action);\n        msgr->push_actions(*actions);\n\n        end_of_round();\n\n        dump_state_stream();\n\n        // Record round duration\n        auto round_end = std::chrono::high_resolution_clock::now();\n        double millis =\n            std::chrono::duration<double, std::milli>(round_end - round_start)\n                .count();\n        // For simplicity, the player turn duration == round duration.\n        for (const auto& player : players_)\n            player->turn_duration_ms.push_back(millis);\n    }\n\n    at_end();\n    at_server_end(msgr);\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.SynchronousRules.server_loop:void(ANY)","name":"server_loop"},{"id":167,"code":"TurnBasedRules::TurnBasedRules(const Options& opt)\n    : Rules(opt)\n{\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.TurnBasedRules.TurnBasedRules:ANY(rules.Options&)","name":"TurnBasedRules"},{"id":168,"code":"void TurnBasedRules::player_loop(ClientMessenger_sptr msgr)\n{\n    uint32_t last_player_id;\n    msgr->pull_id(&last_player_id);\n\n    at_start();\n    at_player_start(msgr);\n\n    start_of_round();\n    while (!is_finished())\n    {\n        uint32_t playing_id;\n\n        DEBUG(\"Waiting for a turn...\");\n        /* Other players turns */\n        if (msgr->wait_for_turn(opt_.player->id, &playing_id))\n        {\n            if (is_spectator(playing_id))\n            {\n                /* Actions of spectators are not published. */\n                DEBUG(\"Turn for spectator %d, never mind...\", playing_id);\n                start_of_spectator_turn(playing_id);\n                start_of_turn(playing_id);\n                end_of_spectator_turn(playing_id);\n                end_of_turn(playing_id);\n                continue;\n            }\n\n            DEBUG(\"Turn for player %d (not me)\", playing_id);\n            start_of_player_turn(playing_id);\n            start_of_turn(playing_id);\n\n            /* Get current player actions */\n            Actions* actions = get_actions();\n            actions->clear();\n            DEBUG(\"Getting actions...\");\n            msgr->pull_actions(actions);\n            DEBUG(\"Got %u actions\", actions->size());\n\n            /* Apply them onto the gamestate */\n            for (const auto& action : actions->all())\n                apply_action(*action);\n        }\n        else /* Current player turn */\n        {\n            DEBUG(\"Turn for player %d (me!!!)\", playing_id);\n            auto turn_start = std::chrono::high_resolution_clock::now();\n\n            start_of_player_turn(playing_id);\n            start_of_turn(playing_id);\n\n            get_actions()->clear();\n            player_turn();\n            Actions* actions = get_actions();\n            DEBUG(\"Sending %u actions...\", actions->size());\n            msgr->send_actions(*actions);\n            DEBUG(\"Waiting for acknowledgement...\");\n            msgr->wait_for_ack();\n            DEBUG(\"Getting actions...\");\n            msgr->pull_actions(actions);\n            DEBUG(\"Got %u actions\", actions->size());\n            actions->clear();\n\n            // Record turn duration\n            auto turn_end = std::chrono::high_resolution_clock::now();\n            double millis =\n                std::chrono::duration<double, std::milli>(turn_end - turn_start)\n                    .count();\n            players_[playing_id]->turn_duration_ms.push_back(millis);\n        }\n        end_of_player_turn(playing_id);\n        end_of_turn(playing_id);\n\n        /* End of each round */\n        if (last_player_id == playing_id)\n        {\n            DEBUG(\"End of turn!\");\n            end_of_round();\n            if (!is_finished())\n                start_of_round();\n            else\n                break; // Avoid calling is_finished() twice\n        }\n    }\n\n    at_end();\n    at_player_end(msgr);\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.TurnBasedRules.player_loop:void(ANY)","name":"player_loop"},{"id":169,"code":"void TurnBasedRules::replay_loop(ReplayMessenger_sptr msgr)\n{\n    at_start();\n\n    auto actions = get_actions();\n    while (!is_finished())\n    {\n        start_of_round();\n        for (const auto& player : players_)\n        {\n            DEBUG(\"Turn for player: %d\", player->id);\n\n            start_of_player_turn(player->id);\n            start_of_turn(player->id);\n\n            msgr->pull_actions(actions);\n            DEBUG(\"Pulled %d actions\", actions->size());\n            for (const auto& action : actions->all())\n                apply_action(*action);\n            actions->clear();\n\n            end_of_player_turn(player->id);\n            end_of_turn(player->id);\n\n            for (const auto& spectator : spectators_)\n            {\n                DEBUG(\"Turn for spectator %d\", spectator->id);\n\n                start_of_spectator_turn(spectator->id);\n                start_of_turn(spectator->id);\n\n                msgr->pull_actions(actions);\n                DEBUG(\"Pulled %d actions\", actions->size());\n                for (const auto& action : actions->all())\n                    apply_action(*action);\n                actions->clear();\n\n                end_of_spectator_turn(spectator->id);\n                end_of_turn(spectator->id);\n            }\n        }\n        end_of_round();\n    }\n\n    at_end();\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.TurnBasedRules.replay_loop:void(ANY)","name":"replay_loop"},{"id":170,"code":"void TurnBasedRules::spectator_loop(ClientMessenger_sptr msgr)\n{\n    bool last_round = false;\n    uint32_t last_player_id;\n    msgr->pull_id(&last_player_id);\n\n    at_start();\n    at_spectator_start(msgr);\n\n    start_of_round();\n    uint32_t previous_playing_id = static_cast<uint32_t>(-1);\n    /* `last_round` allows us to inspect the final state of the game, when no\n     * other player can play anymore. */\n    while (last_round || !is_finished())\n    {\n\n        uint32_t playing_id;\n        bool my_turn = false;\n\n        DEBUG(\"Waiting for a turn...\");\n        /* Other players turns */\n        if (msgr->wait_for_turn(opt_.player->id, &playing_id))\n        {\n            if (is_spectator(playing_id))\n            {\n                DEBUG(\"Turn for spectator %d, never mind...\", playing_id);\n                start_of_spectator_turn(playing_id);\n                start_of_turn(playing_id);\n                end_of_spectator_turn(playing_id);\n                end_of_turn(playing_id);\n                continue;\n            }\n\n            DEBUG(\"Turn for player %d\", playing_id);\n            previous_playing_id = playing_id;\n            start_of_player_turn(playing_id);\n            start_of_turn(playing_id);\n\n            /* Get current player actions */\n            Actions* actions = get_actions();\n            actions->clear();\n            DEBUG(\"Getting actions...\");\n            msgr->pull_actions(actions);\n            DEBUG(\"Got %u actions\", actions->size());\n\n            /* Apply them onto the gamestate */\n            for (const auto& action : actions->all())\n                apply_action(*action);\n\n            end_of_player_turn(playing_id);\n        }\n        else /* Current player turn */\n        {\n            DEBUG(\"Turn for spectator %d (me!!!)\", playing_id);\n            my_turn = true;\n            start_of_spectator_turn(playing_id);\n            start_of_turn(playing_id);\n\n            get_actions()->clear();\n            spectator_turn();\n            /* The server is waiting for this spectator actions, so the\n             * spectator can (on intend) hang some time so the user can inspect\n             * the state of the game. */\n            Actions* actions = get_actions();\n            DEBUG(\"Sending %u actions...\", actions->size());\n            msgr->send_actions(*actions);\n            DEBUG(\"Waiting for acknowledgement...\");\n            msgr->wait_for_ack();\n            /* The server do not publish spectators' actions: do not try to\n             * pull them.  */\n            end_of_spectator_turn(playing_id);\n        }\n\n        end_of_turn(playing_id);\n\n        /* End of each round */\n        if (last_round)\n        {\n            /* If that was the last round, stop there. */\n            DEBUG(\"That was the last turn, bye!\");\n            break;\n        }\n        if (last_player_id == previous_playing_id && my_turn)\n        {\n            DEBUG(\"End of round!\");\n            end_of_round();\n            if (!is_finished())\n                start_of_round();\n            else\n            {\n                DEBUG(\"The next round will be the last one!\");\n                last_round = true;\n            }\n        }\n    }\n\n    at_end();\n    at_spectator_end(msgr);\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.TurnBasedRules.spectator_loop:void(ANY)","name":"spectator_loop"},{"id":171,"code":"void TurnBasedRules::server_loop(ServerMessenger_sptr msgr)\n{\n    // Send last player id, assumes players_ is sorted.\n    msgr->push_id(players_.back()->id);\n\n    at_start();\n    at_server_start(msgr);\n\n    start_of_round();\n\n    dump_state_stream();\n\n    while (!is_finished())\n    {\n        for (const auto& player : players_)\n        {\n            auto turn_start = std::chrono::high_resolution_clock::now();\n\n            start_of_player_turn(player->id);\n            start_of_turn(player->id);\n\n            DEBUG(\"Turn for player %d\", player->id);\n            msgr->push_id(player->id);\n            Actions* actions = get_actions();\n            actions->clear();\n\n            if (player->nb_timeout < max_consecutive_timeout)\n            {\n                if (!msgr->poll(timeout_ > 0 ? timeout_ : -1))\n                {\n                    player->nb_timeout++;\n                    DEBUG(\"Timeout reached, never mind: %d\",\n                          player->nb_timeout);\n                }\n                else\n                {\n                    DEBUG(\"Getting actions...\");\n                    msgr->recv_actions(actions);\n                    DEBUG(\"Got %u actions\", actions->size());\n                    DEBUG(\"Acknowledging...\");\n                    msgr->ack();\n\n                    for (const auto& action : actions->all())\n                        apply_action(*action);\n                }\n            }\n\n            metrics_[\"actions_total\"] += actions->size();\n            save_player_actions(actions);\n            msgr->push_actions(*actions);\n\n            end_of_player_turn(player->id);\n            end_of_turn(player->id);\n\n            dump_state_stream();\n\n            // Record turn duration\n            auto turn_end = std::chrono::high_resolution_clock::now();\n            double millis =\n                std::chrono::duration<double, std::milli>(turn_end - turn_start)\n                    .count();\n            player->turn_duration_ms.push_back(millis);\n\n            /* Spectators must be able to see the state of the game between\n             * after each player has finished its turn. */\n            for (const auto& s : spectators_)\n            {\n                start_of_spectator_turn(s->id);\n                start_of_turn(s->id);\n\n                DEBUG(\"Turn for spectator %d\", s->id);\n                msgr->push_id(s->id);\n                Actions* actions = get_actions();\n                actions->clear();\n                DEBUG(\"Receiving its only Ack action...\");\n                msgr->recv_actions(actions);\n                DEBUG(\"Acknowledging...\");\n                msgr->ack();\n\n                save_player_actions(actions);\n\n                end_of_spectator_turn(s->id);\n                end_of_turn(s->id);\n            }\n        }\n\n        end_of_round();\n        DEBUG(\"End of round!\");\n        if (!is_finished())\n            start_of_round();\n        else\n            break; // Avoid calling is_finished() twice\n    }\n\n    at_end();\n    at_server_end(msgr);\n\n    write_stats();\n}","filename":"src/lib/rules/rules.cc","fullname":"rules.TurnBasedRules.server_loop:void(ANY)","name":"server_loop"},{"id":172,"code":"ServerMessenger::ServerMessenger(net::ServerSocket* sckt)\n    : sckt_(sckt)\n    , last_client_id_(-1)\n{\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.ServerMessenger:ANY(ANY)","name":"ServerMessenger"},{"id":173,"code":"void ServerMessenger::send(const utils::Buffer& buf)\n{\n    utils::Buffer out_buf;\n    net::Message msg(net::MSG_RULES);\n\n    msg.handle_buffer(out_buf);\n    out_buf += buf;\n\n    if (!sckt_->send(out_buf))\n        FATAL(\"Unable to send data to client\");\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.send:void(ANY)","name":"send"},{"id":174,"code":"void ServerMessenger::push(const utils::Buffer& buf)\n{\n    utils::Buffer out_buf;\n    net::Message msg(net::MSG_RULES);\n\n    msg.handle_buffer(out_buf);\n    out_buf += buf;\n\n    sckt_->push(out_buf);\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.push:void(ANY)","name":"push"},{"id":175,"code":"bool ServerMessenger::poll(long timeout)\n{\n    return sckt_->poll(timeout);\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.poll:bool(long int)","name":"poll"},{"id":176,"code":"void ServerMessenger::push_actions(Actions& actions)\n{\n    utils::Buffer buf;\n    actions.handle_buffer(buf);\n    push(buf);\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.push_actions:void(rules.Actions&)","name":"push_actions"},{"id":177,"code":"void ServerMessenger::push_id(uint32_t id)\n{\n    utils::Buffer buf;\n    buf.handle(id);\n    push(buf);\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.push_id:void(ANY)","name":"push_id"},{"id":178,"code":"std::unique_ptr<utils::Buffer> ServerMessenger::recv()\n{\n    auto buf = sckt_->recv();\n    if (!buf)\n        FATAL(\"Unable to receive data from client\");\n\n    net::Message msg;\n    msg.handle_buffer(*buf);\n\n    last_client_id_ = msg.client_id;\n    CHECK_EXC(ServerMessengerError, msg.type == net::MSG_RULES);\n\n    return buf;\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.recv:ANY()","name":"recv"},{"id":179,"code":"void ServerMessenger::recv_actions(Actions* actions)\n{\n    actions->handle_buffer(*recv());\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.recv_actions:void(rules.Actions*)","name":"recv_actions"},{"id":180,"code":"void ServerMessenger::ack()\n{\n    utils::Buffer buf;\n    net::Message msg(net::MSG_ACK);\n\n    msg.handle_buffer(buf);\n\n    if (!sckt_->send(buf))\n        FATAL(\"Unable to send ack to client\");\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.ack:void()","name":"ack"},{"id":181,"code":"void ServerMessenger::wait_for_ack()\n{\n    auto buf = sckt_->recv();\n    if (!buf)\n        FATAL(\"Unable to receive ack from client\");\n\n    net::Message msg;\n    msg.handle_buffer(*buf);\n\n    CHECK_EXC(ServerMessengerError, msg.type == net::MSG_ACK);\n}","filename":"src/lib/rules/server-messenger.cc","fullname":"rules.ServerMessenger.wait_for_ack:void()","name":"wait_for_ack"},{"id":182,"code":"DLLError::DLLError()\n    : std::runtime_error(dlerror())\n{\n}","filename":"src/lib/utils/dll.cc","fullname":"utils.DLLError.DLLError:ANY()","name":"DLLError"},{"id":183,"code":"DLL::DLL(const std::string& filename)\n    : filename_(filename)\n    , handle_(dlopen(filename.c_str(), RTLD_NOW | RTLD_GLOBAL))\n{\n    CHECK_EXC(DLLError, handle_ != nullptr);\n    if (handle_ == nullptr)\n        WARN(\"Cannot open shared library: %d\", filename.c_str());\n}","filename":"src/lib/utils/dll.cc","fullname":"utils.DLL.DLL:ANY(ANY)","name":"DLL"},{"id":184,"code":"DLL::~DLL()\n{\n    dlclose(handle_);\n}","filename":"src/lib/utils/dll.cc","fullname":"utils.DLL.~DLL:ANY()","name":"~DLL"},{"id":185,"code":"void* DLL::get_untyped(const std::string& sym)\n{\n    DEBUG(\"getting symbol %s in %s\", sym.c_str(), filename_.c_str());\n\n    void* sym_value = dlsym(handle_, sym.c_str());\n    CHECK_EXC(DLLError, sym_value != nullptr);\n    return sym_value;\n}","filename":"src/lib/utils/dll.cc","fullname":"utils.DLL.get_untyped:void*(ANY)","name":"get_untyped"},{"id":186,"code":"Logger::Logger()\n    : level_(static_cast<Logger::DisplayLevel>(FLAGS_verbose))\n{\n}","filename":"src/lib/utils/log.cc","fullname":"utils.Logger.Logger:ANY()","name":"Logger"},{"id":187,"code":"void log(Logger::DisplayLevel lvl, const char* file, int line,\n         const char* module_name, const char* module_color, const char* fmt,\n         ...)\n{\n    // Check if the current verbosity level is enough\n    if (lvl > Logger::get().level())\n        return;\n\n    va_list va;\n    va_start(va, fmt);\n\n    char buffer[4096];\n    char fmt_buffer[4096];\n\n    // Only display the basename of the file, not the full path\n    const char* filename = strrchr(file, '/');\n    if (filename)\n        file = filename + 1;\n\n    // Format the log message\n    snprintf(fmt_buffer, sizeof(fmt_buffer), \"[%s%s%s] %s (%s:%d)\",\n             module_color, module_name, ANSI_COL_NONE, fmt, file, line);\n    vsnprintf(buffer, sizeof(buffer), fmt_buffer, va);\n\n    Logger::get().stream() << buffer << std::endl;\n\n    va_end(va);\n}","filename":"src/lib/utils/log.cc","fullname":"utils.log:void(utils.Logger.DisplayLevel,char*,int,char*,char*,char*)","name":"log"},{"id":188,"code":"int main(int argc, char** argv)\n{\n    GFLAGS_NAMESPACE::ParseCommandLineFlags(&argc, &argv, true);\n\n    Replay replay{};\n    if (!replay.check())\n        return EXIT_FAILURE;\n    replay.run();\n    return EXIT_SUCCESS;\n}","filename":"src/replay/main.cc","fullname":"main:int(int,char**)","name":"main"},{"id":189,"code":"[&replay_data](const char c) { replay_data.push_back(c); });","filename":"src/replay/replay.cc","fullname":"Replay.read_replay:ANY(ANY).<lambda>0","name":"<lambda>0"},{"id":190,"code":"bool Replay::check() const\n{\n    if (FLAGS_rules.empty())\n    {\n        ERR(\"--rules cannot be empty\");\n        return false;\n    }\n    if (FLAGS_replay.empty())\n    {\n        ERR(\"--replay cannot be empty\");\n        return false;\n    }\n    return true;\n}","filename":"src/replay/replay.cc","fullname":"Replay.check:bool()","name":"check"},{"id":191,"code":"void Replay::run()\n{\n    // Get required functions from the rules library\n    auto rules_lib = std::make_unique<utils::DLL>(FLAGS_rules);\n    auto rules_init = rules_lib->get<rules::f_rules_init>(\"rules_init\");\n    auto replay_loop = rules_lib->get<rules::f_replay_loop>(\"replay_loop\");\n    auto rules_result = rules_lib->get<rules::f_rules_result>(\"rules_result\");\n\n    auto replay = read_replay(FLAGS_replay);\n    DEBUG(\"Read %d bytes from %s\", replay.size(), FLAGS_replay.c_str());\n\n    auto map_content = read_map(&replay);\n    if (map_content.empty())\n        DEBUG(\"No map in replay\");\n    else\n        DEBUG(\"Read map of %d bytes\", map_content.size());\n\n    auto players = read_players(&replay);\n    DEBUG(\"Read %d players from replay\", players.size());\n\n    auto spectators = read_players(&replay);\n    if (spectators.size() == 0)\n        DEBUG(\"No spectator in replay\");\n    else\n        DEBUG(\"Read %d spectators from replay\", spectators.size());\n\n    // Set the rules options\n    rules::Options rules_opt{};\n    rules_opt.map_content = map_content;\n    rules_opt.verbose = FLAGS_verbose;\n    rules_opt.players = players;\n    rules_opt.spectators = spectators;\n    rules_init(rules_opt);\n\n    // Process actions from replay\n    auto msgr = std::make_shared<rules::ReplayMessenger>(&replay);\n    replay_loop(msgr);\n\n    rules_result();\n\n    auto replay_result = read_result(&replay);\n\n    if (!replay.empty())\n        WARN(\"Replay contains %d extra bytes\", replay.size());\n\n    // Compare saved and replayed results\n    if (!compare_results(replay_result, players))\n    {\n        WARN(\"Match results mismatch!\");\n        WARN(\"Results saved in replay:\");\n        std::cout << replay_result.scores_yaml();\n        WARN(\"Computed results:\");\n    }\n\n    std::cout << players.scores_yaml();\n}","filename":"src/replay/replay.cc","fullname":"Replay.run:void()","name":"run"},{"id":192,"code":"utils::Buffer Replay::read_replay(const std::string& replay_path)\n{\n    auto stream = std::ifstream(replay_path, std::ios::binary);\n    std::vector<uint8_t> replay_data;\n    std::for_each(std::istreambuf_iterator<char>(stream),\n                  std::istreambuf_iterator<char>(),\n                  [&replay_data](const char c) { replay_data.push_back(c); });\n    return utils::Buffer{replay_data};\n}","filename":"src/replay/replay.cc","fullname":"Replay.read_replay:ANY(ANY)","name":"read_replay"},{"id":193,"code":"std::string Replay::read_map(utils::Buffer* replay)\n{\n    std::string map;\n    replay->handle(map);\n    return map;\n}","filename":"src/replay/replay.cc","fullname":"Replay.read_map:ANY(ANY)","name":"read_map"},{"id":194,"code":"rules::Players Replay::read_players(utils::Buffer* replay)\n{\n    rules::Players players;\n    replay->handle_bufferizable(&players);\n    return players;\n}","filename":"src/replay/replay.cc","fullname":"Replay.read_players:ANY(ANY)","name":"read_players"},{"id":195,"code":"rules::Players Replay::read_result(utils::Buffer* replay)\n{\n    // Final scores are extracted from the players save\n    return read_players(replay);\n}","filename":"src/replay/replay.cc","fullname":"Replay.read_result:ANY(ANY)","name":"read_result"},{"id":196,"code":"bool Replay::compare_results(const rules::Players& ref,\n                             const rules::Players& actual) const\n{\n    if (ref.size() != actual.size())\n        return false;\n    for (size_t i = 0; i < ref.size(); ++i)\n    {\n        const auto& player_ref = ref[i];\n        const auto& player_actual = actual[i];\n        if (player_ref->id != player_actual->id)\n            return false;\n        if (player_ref->name != player_actual->name)\n            return false;\n        if (player_ref->score != player_actual->score)\n            return false;\n    }\n    return true;\n}","filename":"src/replay/replay.cc","fullname":"Replay.compare_results:bool(ANY,ANY)","name":"compare_results"},{"id":197,"code":"int main(int argc, char** argv)\n{\n    GFLAGS_NAMESPACE::ParseCommandLineFlags(&argc, &argv, true);\n\n    // The game is on, Mrs Hudson!\n    Server server;\n    server.run();\n}","filename":"src/server/main.cc","fullname":"main:int(int,char**)","name":"main"},{"id":198,"code":"Server::Server()\n{\n    rules_lib_ = std::make_unique<utils::DLL>(FLAGS_rules);\n    // Get required functions from the rules library\n    rules_config = rules_lib_->get<rules::f_rules_config>(\"rules_config\");\n    rules_init = rules_lib_->get<rules::f_rules_init>(\"rules_init\");\n    server_loop = rules_lib_->get<rules::f_server_loop>(\"server_loop\");\n    rules_result = rules_lib_->get<rules::f_rules_result>(\"rules_result\");\n}","filename":"src/server/server.cc","fullname":"Server.Server:ANY()","name":"Server"},{"id":199,"code":"void Server::run()\n{\n    // Launch the network server, listen for connections\n    sckt_init();\n\n    INFO(\"Server Started\");\n\n    // The rules configure the server\n    rules_config(&config_);\n    NOTICE(\"Game configuration:\");\n    NOTICE(\"- name: %s\", config_.name);\n    NOTICE(\"- %d players\", config_.player_count);\n\n    // We have to wait for the required number of clients specified in the\n    // command line\n    wait_for_clients();\n\n    // Create a messenger for sending rules messages\n    msgr_ = std::make_unique<rules::ServerMessenger>(sckt_.get());\n\n    // Load map, if given\n    auto map_content = rules::read_map_from_path(FLAGS_map);\n\n    // Set the rules options\n    rules::Options rules_opt;\n    rules_opt.champion_lib = \"\";\n    rules_opt.time = FLAGS_time;\n    rules_opt.map_file = FLAGS_map;\n    rules_opt.map_content = map_content;\n    rules_opt.verbose = FLAGS_verbose;\n    rules_opt.players = players_;\n    rules_opt.spectators = spectators_;\n\n    // Create dump output stream\n    if (!FLAGS_dump.empty())\n    {\n        std::shared_ptr<std::ofstream> dump_stream =\n            std::make_shared<std::ofstream>(FLAGS_dump);\n        if (!dump_stream->is_open())\n            FATAL(\"Cannot open dump file for writing %s: %s\",\n                  FLAGS_dump.c_str(), strerror(errno));\n        rules_opt.dump_stream = std::move(dump_stream);\n    }\n\n    // Create replay output stream\n    rules_opt.replay_stream = replay_init();\n\n    // Rules specific initializations\n    rules_init(rules_opt);\n\n    // Send the server ACK to start the game\n    utils::Buffer buf_gamestart;\n    net::Message msg_gamestart(net::MSG_GAMESTART);\n    msg_gamestart.handle_buffer(buf_gamestart);\n    sckt_->push(buf_gamestart);\n\n    // Play the game\n    server_loop(msgr_);\n\n    // Results\n    rules_result();\n\n    // Print results\n    std::cout << players_.scores_yaml();\n\n    // Save results\n    replay_save_results(rules_opt.replay_stream);\n\n    sckt_close();\n}","filename":"src/server/server.cc","fullname":"Server.run:void()","name":"run"},{"id":200,"code":"void Server::sckt_init()\n{\n    sckt_ = std::make_unique<net::ServerSocket>(FLAGS_pub_addr, FLAGS_rep_addr);\n    sckt_->init();\n\n    NOTICE(\"Replying on %s\", FLAGS_pub_addr.c_str());\n    NOTICE(\"Publishing on %s\", FLAGS_rep_addr.c_str());\n}","filename":"src/server/server.cc","fullname":"Server.sckt_init:void()","name":"sckt_init"},{"id":201,"code":"void Server::sckt_close()\n{\n    sckt_->close();\n}","filename":"src/server/server.cc","fullname":"Server.sckt_close:void()","name":"sckt_close"},{"id":202,"code":"bool used_identifier(uint32_t player_id, const rules::Players& players)\n{\n    for (const auto& player : players)\n        if (player->id == player_id)\n            return true;\n    return false;\n}","filename":"src/server/server.cc","fullname":"used_identifier:bool(ANY,ANY)","name":"used_identifier"},{"id":203,"code":"void Server::wait_for_clients()\n{\n    if (FLAGS_nb_clients <= 0)\n        FATAL(\"Server started with --nb_clients <= 0.\");\n\n    int spectator_count = FLAGS_nb_clients - config_.player_count;\n    if (spectator_count < 0)\n        FATAL(\"Server must be started with at least --nb_clients %d\",\n              config_.player_count);\n\n    NOTICE(\"Waiting for %d clients: %d players, %d spectators...\",\n           FLAGS_nb_clients, config_.player_count, spectator_count);\n\n    // For each client connecting, we send back a unique id\n    // Clients are players or spectators\n    // Player IDs must be in [0-NB_PLAYER[\n    // Spectator IDs must be in [NB_PLAYER-NB_CLIENTS[\n\n    while (players_.size() + spectators_.size() <\n           static_cast<size_t>(FLAGS_nb_clients))\n    {\n        auto buf_req = sckt_->recv();\n\n        if (!buf_req)\n            continue;\n\n        NOTICE(\"New client\");\n\n        net::Message id_req;\n        id_req.handle_buffer(*buf_req);\n\n        if (id_req.type != net::MSG_CONNECT)\n        {\n            ERR(\"Message is not of type MSG_CONNECT, ignoring request\");\n            continue;\n        }\n\n        int32_t player_id = id_req.client_id;\n        uint32_t client_type;\n        buf_req->handle(client_type);\n\n        rules::PlayerType player_type =\n            static_cast<rules::PlayerType>(client_type);\n\n        if (player_id == -1)\n        {\n            // Client requests an ID from the server\n            if (player_type == rules::PLAYER)\n                player_id = players_.size();\n            else\n                player_id = config_.player_count + spectators_.size();\n\n            NOTICE(\"Client did not specify an identifier, picking %d\",\n                   player_id);\n        }\n\n        if (used_identifier(player_id, players_) ||\n            used_identifier(player_id, spectators_))\n        {\n            ERR(\"Client identifier %d is already used\", player_id);\n            player_id = -1; // Treated by client as invalid\n        }\n\n        if (player_id < -1)\n        {\n            ERR(\"Client identifier %d is invalid\", player_id);\n            player_id = -1; // Treated by client as invalid\n        }\n\n        if (player_type == rules::PLAYER && player_id >= config_.player_count)\n        {\n            ERR(\"Invalid player identifier %d > %d\", player_id,\n                config_.player_count - 1);\n            player_id = -1; // Treated by client as invalid\n        }\n\n        if (player_type == rules::SPECTATOR &&\n            (player_id < config_.player_count || player_id >= FLAGS_nb_clients))\n        {\n            ERR(\"Spectator identifier %d invalid, expecting %d spectators\",\n                player_id, spectator_count - spectators_.size());\n            player_id = -1; // Treated by client as invalid\n        }\n\n        // Send the reply with a uid\n        net::Message id_rep(net::MSG_CONNECT, player_id);\n        utils::Buffer buf_rep;\n        id_rep.handle_buffer(buf_rep);\n        sckt_->send(buf_rep);\n\n        if (player_id == -1)\n            continue; // Do not add invalid clients\n\n        auto new_client = std::make_shared<rules::Player>(\n            static_cast<uint32_t>(player_id), client_type);\n        buf_req->handle(new_client->name);\n\n        // Add the player to the list\n        if (client_type == rules::SPECTATOR)\n            spectators_.add(new_client);\n        else\n            players_.add(new_client);\n\n        NOTICE(\"Client connected - id: %i - type: %s\", new_client->id,\n               rules::playertype_str(\n                   static_cast<rules::PlayerType>(new_client->type))\n                   .c_str());\n    }\n\n    players_.sort();\n    spectators_.sort();\n\n    // Then send players info to all clients\n    utils::Buffer buf_players;\n    net::Message msg_players(net::MSG_PLAYERS);\n\n    msg_players.handle_buffer(buf_players);\n    players_.handle_buffer(buf_players);\n\n    sckt_->push(buf_players, 0, 500);\n\n    // And spectators\n    utils::Buffer buf_spectators;\n    net::Message msg_spectators(net::MSG_PLAYERS);\n\n    msg_spectators.handle_buffer(buf_spectators);\n    spectators_.handle_buffer(buf_spectators);\n\n    sckt_->push(buf_spectators);\n}","filename":"src/server/server.cc","fullname":"Server.wait_for_clients:void()","name":"wait_for_clients"},{"id":204,"code":"std::shared_ptr<std::ostream> Server::replay_init()\n{\n    if (FLAGS_replay.empty())\n        return {};\n\n    auto ofs = std::make_shared<std::ofstream>(FLAGS_replay, std::ios::binary);\n    if (!ofs->is_open())\n        FATAL(\"Cannot open replay file for writing %s: %s\",\n              FLAGS_replay.c_str(), strerror(errno));\n\n    auto map_content = rules::read_map_from_path(FLAGS_map);\n\n    // Save state to replay file\n    utils::Buffer buf;\n    buf.handle(map_content);\n    buf.handle_bufferizable(&players_);\n    buf.handle_bufferizable(&spectators_);\n    *ofs << buf;\n\n    return ofs;\n}","filename":"src/server/server.cc","fullname":"Server.replay_init:ANY()","name":"replay_init"},{"id":205,"code":"void Server::replay_save_results(std::shared_ptr<std::ostream> replay_stream)\n{\n    if (!replay_stream)\n        return;\n    utils::Buffer buf;\n    buf.handle_bufferizable(&players_);\n    *replay_stream << buf;\n}","filename":"src/server/server.cc","fullname":"Server.replay_save_results:void(ANY)","name":"replay_save_results"},{"id":206,"code":"Api::Api(std::unique_ptr<GameState> game_state, rules::Player_sptr player)\n    : rules::Api<GameState, error>(std::move(game_state), player)\n{\n    api = this;\n}","filename":"tools/rubygenerator/files/api.cc","fullname":"Api.Api:ANY(ANY,ANY)","name":"Api"},{"id":207,"code":"void rules_init(const rules::Options& opt)\n    {\n        utils::Logger::get().level() = (utils::Logger::DisplayLevel)opt.verbose;\n        rules_ = new Rules(opt);\n    }","filename":"tools/rubygenerator/files/entry.cc","fullname":"rules_init","name":"rules_init"},{"id":208,"code":"void rules_result()\n    {\n        delete rules_;\n    }","filename":"tools/rubygenerator/files/entry.cc","fullname":"rules_result","name":"rules_result"},{"id":209,"code":"void player_loop(rules::ClientMessenger_sptr msgr)\n    {\n        rules_->player_loop(msgr);\n    }","filename":"tools/rubygenerator/files/entry.cc","fullname":"player_loop","name":"player_loop"},{"id":210,"code":"void replay_loop(rules::ReplayMessenger_sptr msgr)\n    {\n        rules_->replay_loop(msgr);\n    }","filename":"tools/rubygenerator/files/entry.cc","fullname":"replay_loop","name":"replay_loop"},{"id":211,"code":"void server_loop(rules::ServerMessenger_sptr msgr)\n    {\n        rules_->server_loop(msgr);\n    }","filename":"tools/rubygenerator/files/entry.cc","fullname":"server_loop","name":"server_loop"},{"id":212,"code":"void spectator_loop(rules::ClientMessenger_sptr msgr)\n    {\n        rules_->spectator_loop(msgr);\n    }","filename":"tools/rubygenerator/files/entry.cc","fullname":"spectator_loop","name":"spectator_loop"},{"id":213,"code":"GameState::GameState(rules::Players_sptr players)\n    : rules::GameState()\n    , players_(players)\n{\n    // FIXME\n}","filename":"tools/rubygenerator/files/game_state.cc","fullname":"GameState.GameState:ANY(ANY)","name":"GameState"},{"id":214,"code":"GameState::GameState(const GameState& st)\n    : rules::GameState(st)\n    , players_(st.players_)\n{\n    // FIXME\n}","filename":"tools/rubygenerator/files/game_state.cc","fullname":"GameState.GameState:ANY(GameState &)","name":"GameState"},{"id":215,"code":"GameState::~GameState()\n{\n    // FIXME\n}","filename":"tools/rubygenerator/files/game_state.cc","fullname":"GameState.~GameState:ANY()","name":"~GameState"},{"id":216,"code":"GameState* GameState::copy() const\n{\n    return new GameState(*this);\n}","filename":"tools/rubygenerator/files/game_state.cc","fullname":"GameState.copy:GameState*()","name":"copy"},{"id":217,"code":"std::ostream& operator<<(std::ostream& os, const std::vector<T>& arr)\n{\n    os << \"[\";\n    typename std::vector<T>::const_iterator it;\n    for (it = arr.begin(); it != arr.end(); ++it)\n    {\n        if (it != arr.begin())\n            os << \", \";\n        os << *it;\n    }\n    os << \"]\";\n    return os;\n}","filename":"tools/rubygenerator/files/interface.cc","fullname":"<<:ANY(ANY,ANY)","name":"<<"},{"id":218,"code":"DECLARE_int32(verbose);","filename":"src/lib/utils/log.hh","fullname":"DECLARE_int32","name":"DECLARE_int32"}]